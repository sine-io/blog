### 第一部分

#### 1. 静态语言 vs 动态语言

静态语言（强类型语言）：在**编译时**变量的数据类型就可以确定，大多数静态语言要求在使用变量前必须声明数据类型。

动态语言（弱类型语言）：**运行时**才确定数据类型，变量在使用之前无需声明类型。

#### 2. 强类型 vs 弱类型

强类型语言是必须强制确定数据类型的语言，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这种数据类型。变量的类型是在声明的时候确定的。

弱类型语言是数据类型可以被忽略的语言，一个变量可以赋不同的数据类型的值，一个变量的类型是由其上下文决定的。

#### 3. 编译型 vs 解释型

编译型语言会通过编译器将源代码一次性翻译成机器码，然后执行。--- 执行前先行编译

解释型语言会通过解释器一句一句地将源代码解释成机器码并执行。--- 执行期间动态解释 --- Py自动编译

![](.\img\python讲述-01.png)

#### 4. 指针不可见



### 第二部分

#### 1. Python版本选择

≥ v3.6

#### 2. Python环境安装

自行安装

#### 3. IDE安装

推荐Pycharm 或者 VS Code

### 第三部分

#### 1. 打印语句

```python
print("Hello world")
```

#### 2. 变量与数据类型

##### 2.1 [内存模型](https://blog.csdn.net/u010783226/article/details/121479275)

程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从`0x1000`到`0x8000`，起始地址是较小的那个地址，结束地址是较大的那个地址。

程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址0x1000开始给他分配，一直分配到地址0x100A，如果再要求得到22个字节，那么就分配到0x1020。

这种因为**用户主动请求而划分出来的内存区域，叫做 Heap（堆）**。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个**重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收**。

![](.\img\python讲述-02.png)

除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。

```python
def add_a_and_b():
    a = 123
    b = 456
    print(a+b)  # return None

def main():
    c = "nothing"
    print(c)
    return aaa()
```

上面代码中，`main`函数内部调用了`add_a_and_b`函数。执行到这一行的时候，系统也会为`add_a_and_b`新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：`main`和`add_a_and_b`。一般来说，调用栈有多少层，就有多少帧。

等到add_a_and_b运行结束，它的帧就会被回收，系统会回到函数main刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。

所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做"入栈"，英文是 push；栈的回收叫做"出栈"，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做"**后进先出**"的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。

![](.\img\python讲述-03.png)

从上面的过程看到，程序地址执行，会伴随着内存的寻址。内存的地址不好记录，我们使用一个名字来代替它，这就是变量。

在Python中变量和部分静态语言不一样，它更偏向于”标签“ 或者说 “引用”  ---- 手动画

##### 2.2 变量的定义

```python
a = 1
name = "zhangsan"

name = "lisi"  # 可重复定义，直接更换变量的值

# 变量名要有意义
# 符合Python命名规范:
# a. 字母、数字、下划线组合
# b. 开头不能是数字
# c. 关键字（help() -> keywords）不能当变量名

# 现在也能用中文当变量，但是不建议
```

##### 2.3 数据类型

整形

```python
# 小整数对象池
# -5 ~ 255
```

浮点型

布尔类型

```python
# True
# False
```

字符串

```python
# 字符串格式化
a = 1
b = 2

c = "Hello {0}, Hello {1}".format(a, b)
d = f"Hello {a}, Hello {b}"


'Hi, there'

"Hello, here"

"""
Good morning!
Good afternoon!
Good evening!
"""

# 单引号和双引号的嵌套

# 字符串的各种函数

# 字符串切片

```

类型转换

```python
a = 1
b = str(a)
type(b)
```

变量+数据类型 练习题

```python
# 下面程序的执行结果是什么？
name = "zhangsan"
1st = 1
print(f"{name}是第{1st}个到学校的")
```

```python
# 分苹果练习
# 张三，李四，王五 均分n个苹果，每个人分多少个？
zs = "张三"
ls = "李四"
ww = "王五"
total_apple = 11

avg_num = total_apple/3
print(f"{zs}, {ls}, {ww} 均分{total_apple}个苹果，每个人分到的个数是：{avg_num}")
print(f"{zs}, {ls}, {ww} 均分{total_apple}个苹果，每个人分到的个数是：{avg_num:.2f}")  # 保留2位小数
```

##### 2.4 数据结构

元祖

```python
# 不可变
gender = ("male", "female")  # 安全的, 不许修改元素

# 元祖的元素可以是可变的，不建议用
a = (1, "cc", ["d", "e", 23])

# 下标取元素

# 切片

```

列表

```python
# 可变的
li1 = [1, 2, 'a', 'b']

# 下标取元素

# 切片

# 列表表达式

```

字典

```python
# 可变
# key唯一
# 占内存
dict1 = {"name": "zhangsan", ""}
```

集合

```python

```

